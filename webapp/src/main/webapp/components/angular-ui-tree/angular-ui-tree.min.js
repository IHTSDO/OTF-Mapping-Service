/**
 * @license Angular UI Tree v2.2
 * (c) 2010-2014. https://github.com/JimLiu/angular-ui-tree
 * License: MIT
 */
!function(){"use strict";angular.module("ui.tree",[]).constant("treeConfig",{treeClass:"angular-ui-tree",emptyTreeClass:"angular-ui-tree-empty",hiddenClass:"angular-ui-tree-hidden",nodesClass:"angular-ui-tree-nodes",nodeClass:"angular-ui-tree-node",handleClass:"angular-ui-tree-handle",placeHoldersWrapperClass:"angular-ui-tree-placeholders-wrapper",placeHolderClass:"angular-ui-tree-placeholder",dragClass:"angular-ui-tree-drag",dragWrapperClass:"angular-ui-tree-drag-wrapper",dragUpThreshold:10,levelThreshold:30}).constant("keys",{space:32,enter:13,tab:9,esc:27,escape:27,backspace:8,back:8,shift:16,maj:16,ctrl:17,control:17,alt:18,left:37,leftarrow:37,up:38,uparrow:38,right:39,rightarrow:39,down:40,downarrow:40,ins:45,insert:45,del:46,"delete":46,home:36,end:35,pgup:33,pageup:33,pgdown:34,pagedown:34,f1:112,f2:113,f3:114,f4:115,f5:116,f6:117,f7:118,f8:119,f9:120,f10:121,f11:122,f12:123})}(),function(){"use strict";angular.module("ui.tree").factory("$uiTreeHelper",["$document","$window",function($document,$window){return{nodesData:{},setNodeAttribute:function(scope,attrName,val){if(!scope.$modelValue)return void 0;var data=this.nodesData[scope.$modelValue.$$hashKey];data||(data={},this.nodesData[scope.$modelValue.$$hashKey]=data),data[attrName]=val},getNodeAttribute:function(scope,attrName){if(!scope.$modelValue)return void 0;var data=this.nodesData[scope.$modelValue.$$hashKey];return data?data[attrName]:void 0},nodrag:function(targetElm){return"undefined"!=typeof targetElm.attr("nodrag")},eventObj:function(e){var obj=e;return void 0!==e.targetTouches?obj=e.targetTouches.item(0):void 0!==e.originalEvent&&void 0!==e.originalEvent.targetTouches&&(obj=e.originalEvent.targetTouches.item(0)),obj},dragInfo:function(node){return angular.isDefined(node)?{source:node,sourceInfo:{nodeScope:node,index:angular.isFunction(node.index)?node.index():0,nodesScope:node.$parentNodesScope},index:angular.isFunction(node.index)?node.index():0,siblings:angular.isFunction(node.siblings)?node.siblings().slice(0):[],parent:node.$parentNodesScope,moveTo:function(parent,siblings,index){if(parent.accept(node,index)===!0){this.parent=parent,this.siblings=siblings.slice(0);var i=this.siblings.indexOf(this.source);return i>-1&&(this.siblings.splice(i,1),this.source.index()<index&&index--),this.siblings.splice(index,0,this.source),this.index=index,!0}return!1},parentNode:function(){return this.parent.$nodeScope},prev:function(){return this.index>0?this.siblings[this.index-1]:void 0},next:function(){return this.index<this.siblings.length-1?this.siblings[this.index+1]:void 0},isDirty:function(){return this.source.$parentNodesScope!=this.parent||this.source.index()!=this.index},eventArgs:function(elements,pos){return{source:this.sourceInfo,dest:{index:this.index,nodesScope:this.parent},elements:elements,pos:pos}},apply:function(copy){var nodeData=this.source.$modelValue;if(copy||this.source.remove(),angular.isDefined(this.parent)){var data=copy?angular.copy(nodeData):nodeData,index=this.index;copy&&this.sourceInfo.index<this.index&&this.sourceInfo.nodesScope===this.parent&&(index=this.index+1),this.parent.insertNode(index,data)}}}:void 0},height:function(element){return element.prop("scrollHeight")},width:function(element){return element.prop("scrollWidth")},offset:function(element){var boundingClientRect=element[0].getBoundingClientRect();return{width:element.prop("offsetWidth"),height:element.prop("offsetHeight"),top:boundingClientRect.top+($window.pageYOffset||$document[0].body.scrollTop||$document[0].documentElement.scrollTop),left:boundingClientRect.left+($window.pageXOffset||$document[0].body.scrollLeft||$document[0].documentElement.scrollLeft)}},positionStarted:function(e,target){var pos={};return pos.offsetX=e.pageX-this.offset(target).left,pos.offsetY=e.pageY-this.offset(target).top,pos.startX=pos.lastX=e.pageX,pos.startY=pos.lastY=e.pageY,pos.nowX=pos.nowY=pos.distX=pos.distY=pos.dirAx=0,pos.dirX=pos.dirY=pos.lastDirX=pos.lastDirY=pos.distAxX=pos.distAxY=0,pos},positionMoved:function(e,pos,firstMoving){pos.lastX=pos.nowX,pos.lastY=pos.nowY,pos.nowX=e.pageX,pos.nowY=e.pageY,pos.distX=pos.nowX-pos.lastX,pos.distY=pos.nowY-pos.lastY,pos.lastDirX=pos.dirX,pos.lastDirY=pos.dirY,pos.dirX=0===pos.distX?0:pos.distX>0?1:-1,pos.dirY=0===pos.distY?0:pos.distY>0?1:-1;var newAx=Math.abs(pos.distX)>Math.abs(pos.distY)?1:0;return firstMoving?(pos.dirAx=newAx,void(pos.moving=!0)):(pos.dirAx!==newAx?(pos.distAxX=0,pos.distAxY=0):(pos.distAxX+=Math.abs(pos.distX),0!==pos.dirX&&pos.dirX!==pos.lastDirX&&(pos.distAxX=0),pos.distAxY+=Math.abs(pos.distY),0!==pos.dirY&&pos.dirY!==pos.lastDirY&&(pos.distAxY=0)),void(pos.dirAx=newAx))},findIntersect:function(elmPos,nodes,collideWith,direction,horizontal){for(var intersectWith,self=this,nodeIdx=0;nodeIdx<nodes.length;nodeIdx++){var intersectWithChild,nodeElement=angular.element(nodes[nodeIdx]);if(angular.isDefined(nodeElement[0]))if(nodeElement.hasClass("angular-ui-tree-node"))if(intersectWithChild=self.findIntersect(elmPos,nodeElement.children(),collideWith,direction,horizontal),angular.isUndefined(intersectWithChild)){var isOverElementWidth,isOverElementHeight,nodeOffset=self.offset(nodeElement),nodePos={left:nodeOffset.left,width:nodeOffset.width,right:nodeOffset.left+nodeOffset.width,top:nodeOffset.top,height:nodeOffset.height,bottom:nodeOffset.top+nodeOffset.height};horizontal&&(0>direction?isOverElementWidth="bottom"===collideWith?elmPos.left<=nodePos.right&&elmPos.right>=nodePos.left:elmPos.right<=nodePos.right&&elmPos.right>=nodePos.left:direction>0&&(isOverElementWidth="bottom"===collideWith?elmPos.right>=nodePos.left&&elmPos.left<=nodePos.right:elmPos.left>=nodePos.left&&elmPos.left<=nodePos.right)),0>direction?isOverElementHeight="bottom"===collideWith?elmPos.top<=nodePos.bottom&&elmPos.bottom>=nodePos.top:elmPos.bottom<=nodePos.bottom&&elmPos.bottom>=nodePos.top:direction>0&&(isOverElementHeight="bottom"===collideWith?elmPos.bottom>=nodePos.top&&elmPos.top<=nodePos.bottom:elmPos.top>=nodePos.top&&elmPos.top<=nodePos.bottom),(horizontal&&isOverElementWidth&&isOverElementHeight||!horizontal&&isOverElementHeight)&&(intersectWith=nodes[nodeIdx])}else intersectWith=intersectWithChild;else angular.isDefined(nodeElement.children())&&nodeElement.children().length>0&&(intersectWith=self.findIntersect(elmPos,nodeElement.children(),collideWith,direction,horizontal));if(angular.isDefined(intersectWith))break}return intersectWith}}}])}(),function(){"use strict";angular.module("ui.tree").controller("TreeController",["$scope","$element","$window","$attrs","treeConfig","keys",function($scope,$element,$window,$attrs,treeConfig,keys){this.scope=$scope,$scope.$element=$element,$scope.$treeElement=$element,$scope.$nodesScope=void 0,$scope.$type="uiTree",$scope.$emptyElm=void 0,$scope.$callbacks=void 0,$scope.$selecteds=[],$scope.dragEnabled=angular.isUndefined($scope.dragEnabled)?!0:$scope.dragEnabled,$scope.emptyPlaceholderEnabled=angular.isUndefined($scope.emptyPlaceholderEnabled)?!1:$scope.emptyPlaceholderEnabled,$scope.maxDepth=angular.isUndefined($scope.maxDepth)?10:$scope.maxDepth,$scope.dragDelay=angular.isUndefined($scope.dragDelay)?0:$scope.dragDelay,$scope.dragDistance=angular.isUndefined($scope.dragDistance)?0:$scope.dragDistance,$scope.cancelKey=keys.escape,$scope.lockXKey=void 0,$scope.lockX=!1,$scope.lockYKey=void 0,$scope.lockY=!1,$scope.boundTo=angular.isUndefined($scope.boundTo)?"":$scope.boundTo,$scope.collideWith="bottom",$scope.coverage=.5,$scope.spacing=angular.isUndefined($scope.spacing)?50:$scope.spacing,$scope.spacingThreshold=Math.floor($scope.spacing/4),$scope.copyKey=void 0,$scope.copy=!1,$scope.multiSelectKey=void 0,$scope.multiSelect=!1,$scope.expandOnHover=angular.isUndefined($scope.expandOnHover)?500:$scope.expandOnHover,$scope.$watch("callbacks",function(newOptions){angular.forEach(newOptions,function(value,key){$scope.$callbacks[key]&&angular.isFunction(value)&&($scope.$callbacks[key]=value)})},!0),$scope.$watch("$nodesScope.$modelValue.length",function(){$scope.$nodesScope.$modelValue&&$scope.resetEmptyElement()},!0),$scope.$watch("lockXKeyString",function(val){angular.isString(val)&&(val=val.toLowerCase(),val.length>0&&($scope.lockXKey=angular.isDefined(keys[val])?keys[val]:1===val.length?val.charCodeAt(0)-32:void 0)),$scope.lockX=angular.isUndefined($scope.lockXKey)&&"boolean"==typeof val?val:!1}),$scope.$watch("lockYKeyString",function(val){angular.isString(val)&&(val=val.toLowerCase(),val.length>0&&($scope.lockYKey=angular.isDefined(keys[val])?keys[val]:1===val.length?val.charCodeAt(0)-32:void 0)),$scope.lockY=angular.isUndefined($scope.lockXKey)&&"boolean"==typeof val?val:!1}),$scope.$watch("boundToString",function(val){if(angular.isString(val)&&val.length>0)try{$scope.boundTo=angular.element($window.document.querySelectorAll(val))}catch(exception){$scope.boundTo=""}}),$scope.$watch("spacing",function(val){angular.isNumber(val)&&val>0&&($scope.spacingThreshold=Math.floor($scope.spacing/4))}),$scope.$watch("coveragePercent",function(val){angular.isNumber(val)&&val>=-100&&100>=val&&($scope.collideWith=0>val?"top":"bottom",$scope.coverage=Math.abs(val/100))}),$scope.$watch("cancelKeyString",function(val){angular.isString(val)&&(val=val.toLowerCase(),val.length>0&&($scope.cancelKey=angular.isDefined(keys[val])?keys[val]:val.charCodeAt(0)-32))}),$scope.$watch("copyKeyString",function(val){angular.isString(val)&&(val=val.toLowerCase(),val.length>0&&($scope.copyKey=angular.isDefined(keys[val])?keys[val]:val.charCodeAt(0)-32))}),$scope.$watch("selectKeyString",function(val){angular.isString(val)&&(val=val.toLowerCase(),val.length>0&&($scope.multiSelectKey=angular.isDefined(keys[val])?keys[val]:val.charCodeAt(0)-32))}),$scope.isEmpty=function(){return $scope.$nodesScope&&$scope.$nodesScope.$modelValue&&0===$scope.$nodesScope.$modelValue.length},$scope.place=function(placeElm){$scope.$nodesScope.$element.append(placeElm),$scope.$emptyElm.remove()},$scope.resetEmptyElement=function(){0===$scope.$nodesScope.$modelValue.length&&$scope.emptyPlaceholderEnabled?$element.append($scope.$emptyElm):$scope.$emptyElm.remove()};var collapseOrExpand=function(scope,collapsed){for(var nodes=scope.childNodes(),i=0;i<nodes.length;i++){collapsed?nodes[i].collapse(!0):nodes[i].expand(!0);var subScope=nodes[i].$childNodesScope;subScope&&collapseOrExpand(subScope,collapsed)}};$scope.collapseAll=function(){collapseOrExpand($scope.$nodesScope,!0)},$scope.$on("collapseAll",$scope.collapseAll),$scope.expandAll=function(){collapseOrExpand($scope.$nodesScope,!1)},$scope.$on("expandAll",$scope.expandAll)}])}(),function(){"use strict";angular.module("ui.tree").controller("TreeNodesController",["$scope","$element","$q","treeConfig",function($scope,$element,$q){this.scope=$scope,$scope.$element=$element,$scope.$nodesElement=$element,$scope.$modelValue=void 0,$scope.$nodeScope=void 0,$scope.$treeScope=void 0,$scope.$type="uiTreeNodes",$scope.$nodesMap={},$scope.nodrop=!1,$scope.maxDepth=0,$scope.expandOnHover=void 0,$scope.initSubNode=function(subNode){return subNode.$modelValue?void($scope.$nodesMap[subNode.$modelValue.$$hashKey]=subNode):void 0},$scope.destroySubNode=function(subNode){return subNode.$modelValue?void($scope.$nodesMap[subNode.$modelValue.$$hashKey]=void 0):void 0},$scope.accept=function(sourceNode,destIndex){return $scope.$treeScope.$callbacks.accept(sourceNode,$scope,destIndex)},$scope.beforeDrag=function(sourceNode,event){return $scope.$treeScope.$callbacks.beforeDrag(sourceNode,event)},$scope.isParent=function(node){return node.$parentNodesScope==$scope},$scope.hasChild=function(){return $scope.$modelValue.length>0},$scope.safeApply=function(fn){var phase=this.$root.$$phase;"$apply"==phase||"$digest"==phase?fn&&"function"==typeof fn&&fn():this.$apply(fn)},$scope.removeNode=function(node){var deferred=$q.defer(),index=$scope.$modelValue.indexOf(node.$modelValue);return index>-1?$scope.safeApply(function(){$scope.$modelValue.splice(index,1)[0],deferred.resolve(node)}):deferred.reject("not found"),deferred.promise},$scope.insertNode=function(index,nodeData){var deferred=$q.defer();return $scope.safeApply(function(){$scope.$modelValue.splice(index,0,nodeData),deferred.resolve("inserted")}),deferred.promise},$scope.childNodes=function(){var nodes=[];if($scope.$modelValue)for(var i=0;i<$scope.$modelValue.length;i++)nodes.push($scope.$nodesMap[$scope.$modelValue[i].$$hashKey]);return nodes},$scope.depth=function(){return $scope.$nodeScope?$scope.$nodeScope.depth():0},$scope.outOfDepth=function(sourceNode){var maxDepth=$scope.maxDepth||$scope.$treeScope.maxDepth;return maxDepth>0?$scope.depth()+sourceNode.maxSubDepth()+1>maxDepth:!1}}])}(),function(){"use strict";angular.module("ui.tree").controller("TreeNodeController",["$scope","$element","$attrs","treeConfig",function($scope,$element){this.scope=$scope,$scope.$element=$element,$scope.$nodeElement=$element,$scope.$modelValue=void 0,$scope.$parentNodeScope=void 0,$scope.$childNodesScope=void 0,$scope.$parentNodesScope=void 0,$scope.$treeScope=void 0,$scope.$handleScope=void 0,$scope.$type="uiTreeNode",$scope.$$apply=!1,$scope.$dragInfo=void 0,$scope.collapsed=!1,$scope.expandOnHover=!1,$scope.selected=!1,$scope.init=function(controllersArr){var treeNodesCtrl=controllersArr[0];$scope.$treeScope=controllersArr[1]?controllersArr[1].scope:void 0,$scope.$parentNodeScope=treeNodesCtrl.scope.$nodeScope,$scope.$modelValue=treeNodesCtrl.scope.$modelValue[$scope.$index],$scope.$parentNodesScope=treeNodesCtrl.scope,treeNodesCtrl.scope.initSubNode($scope),$element.on("$destroy",function(){treeNodesCtrl.scope.destroySubNode($scope)})},$scope.toggleSelected=function(){$scope.selected?$scope.unselect():$scope.select()},$scope.select=function(){!$scope.selected&&$scope.$treeScope.$callbacks.select($scope)&&($scope.selected=!0,$scope.$treeScope.$selecteds.push($scope.$element))},$scope.unselect=function(){if($scope.selected&&$scope.$treeScope.$callbacks.unselect($scope)){$scope.selected=!1;var indexOf=$scope.$treeScope.$selecteds.indexOf($scope.$element);angular.isDefined(indexOf)&&indexOf>-1&&$scope.$treeScope.$selecteds.splice(indexOf,1)}},$scope.index=function(){return $scope.$parentNodesScope.$modelValue.indexOf($scope.$modelValue)},$scope.dragEnabled=function(){return!($scope.$treeScope&&!$scope.$treeScope.dragEnabled)},$scope.isSibling=function(targetNode){return $scope.$parentNodesScope===targetNode.$parentNodesScope},$scope.isChild=function(targetNode){var nodes=$scope.childNodes();return nodes&&nodes.indexOf(targetNode)>-1},$scope.prev=function(){var index=$scope.index();return index>0?$scope.siblings()[index-1]:void 0},$scope.siblings=function(){return $scope.$parentNodesScope.childNodes()},$scope.childNodesCount=function(){return angular.isDefined($scope.childNodes())?$scope.childNodes().length:0},$scope.hasChild=function(){return $scope.childNodesCount()>0},$scope.childNodes=function(){return angular.isDefined($scope.$childNodesScope)&&angular.isDefined($scope.$childNodesScope.$modelValue)?$scope.$childNodesScope.childNodes():void 0},$scope.accept=function(sourceNode,destIndex){return angular.isDefined($scope.$childNodesScope)&&angular.isDefined($scope.$childNodesScope.$modelValue)&&$scope.$childNodesScope.accept(sourceNode,destIndex)},$scope.removeNode=function(){if($scope.$treeScope.$callbacks.remove(node)){var node=$scope.remove();return node}return void 0},$scope.remove=function(){return $scope.$parentNodesScope.removeNode($scope)},$scope.toggle=function(){$scope.collapsed=!$scope.collapsed},$scope.collapse=function(all){$scope.collapsed=$scope.$treeScope.$callbacks.collapse($scope,all)},$scope.expand=function(all){$scope.collapsed=!$scope.$treeScope.$callbacks.expand($scope,all)},$scope.depth=function(){var parentNode=$scope.$parentNodeScope;return parentNode?parentNode.depth()+1:1};var subDepth=0,countSubDepth=function(scope){for(var count=0,nodes=scope.childNodes(),i=0;i<nodes.length;i++){var childNodes=nodes[i].$childNodesScope;childNodes&&(count=1,countSubDepth(childNodes))}subDepth+=count};$scope.maxSubDepth=function(){return subDepth=0,$scope.$childNodesScope&&countSubDepth($scope.$childNodesScope),subDepth}}])}(),function(){"use strict";angular.module("ui.tree").controller("TreeHandleController",["$scope","$element","$attrs","treeConfig",function($scope,$element){this.scope=$scope,$scope.$element=$element,$scope.$handleElement=$element,$scope.$nodeScope=void 0,$scope.$type="uiTreeHandle"}])}(),function(){"use strict";angular.module("ui.tree").directive("uiTree",["treeConfig","keys","$window",function(treeConfig,keys,$window){return{restrict:"EA",scope:{callbacks:"=?",dragEnabled:"=?",emptyPlaceholderEnabled:"=?",maxDepth:"=?",dragDelay:"=?",dragDistance:"=?",lockXKeyString:"=?lockX",lockYKeyString:"=?lockY",boundToString:"=?boundTo",spacing:"=?",coveragePercent:"=?coverage",cancelKeyString:"=?cancelKey",copyKeyString:"=?copyKey",selectKeyString:"=?selectKey",expandOnHover:"=?"},controller:"TreeController",link:function(scope,element){var callbacks={accept:void 0,beforeDrag:void 0},config={};angular.extend(config,treeConfig),config.treeClass&&element.addClass(config.treeClass),scope.$emptyElm=angular.element($window.document.createElement("div")),config.emptyTreeClass&&scope.$emptyElm.addClass(config.emptyTreeClass),callbacks.accept=function(sourceNodeScope,destNodesScope){return destNodesScope.nodrop||destNodesScope.outOfDepth(sourceNodeScope)?!1:!0},callbacks.collapse=function(){return!0},callbacks.expand=function(){return!0},callbacks.beforeDrag=function(){return!0},callbacks.expandTimeoutStart=function(){},callbacks.expandTimeoutCancel=function(){},callbacks.expandTimeoutEnd=function(){return!0},callbacks.remove=function(){return!0},callbacks.dropped=function(){},callbacks.droppedInto=function(){},callbacks.dragStart=function(){},callbacks.dragMove=function(){},callbacks.placeholderMove=function(){},callbacks.dragCancel=function(){},callbacks.dragStop=function(){},callbacks.beforeDrop=function(){return!0},callbacks.lock=function(){return!0},callbacks.unlock=function(){return!0},callbacks.startCopy=function(){return!0},callbacks.endCopy=function(){},callbacks.startSelect=function(){return!0},callbacks.select=function(){return!0},callbacks.unselect=function(){return!0},callbacks.endSelect=function(){},scope.$callbacks=callbacks}}}])}(),function(){"use strict";angular.module("ui.tree").directive("uiTreeNodes",["treeConfig",function(treeConfig){return{require:["ngModel","?^uiTreeNode","^uiTree"],restrict:"EA",scope:{maxDepth:"=?",expandOnHover:"=?",noDrop:"=?",horizontal:"=?"},controller:"TreeNodesController",link:function(scope,element,attrs,controllersArr){var config={};angular.extend(config,treeConfig),config.nodesClass&&element.addClass(config.nodesClass);var ngModel=controllersArr[0],treeNodeCtrl=controllersArr[1],treeCtrl=controllersArr[2];treeNodeCtrl?(treeNodeCtrl.scope.$childNodesScope=scope,scope.$nodeScope=treeNodeCtrl.scope):treeCtrl.scope.$nodesScope=scope,scope.$treeScope=treeCtrl.scope,ngModel&&(ngModel.$render=function(){ngModel.$modelValue&&angular.isArray(ngModel.$modelValue)||(scope.$modelValue=[]),scope.$modelValue=ngModel.$modelValue})}}}])}(),function(){"use strict";angular.module("ui.tree").directive("uiTreeNode",["treeConfig","$uiTreeHelper","$window","$document","$timeout","$filter",function(treeConfig,$uiTreeHelper,$window,$document,$timeout,$filter){return{require:["^uiTreeNodes","^uiTree"],restrict:"EA",controller:"TreeNodeController",link:function(scope,element,attrs,controllersArr){var config={};angular.extend(config,treeConfig),config.nodeClass&&element.addClass(config.nodeClass),scope.init(controllersArr),scope.collapsed=!!$uiTreeHelper.getNodeAttribute(scope,"collapsed"),scope.$watch(attrs.collapsed,function(val){"boolean"==typeof val&&(scope.collapsed=val)}),scope.$watch("collapsed",function(val){$uiTreeHelper.setNodeAttribute(scope,"collapsed",val),attrs.$set("collapsed",val)}),scope.selected=!!$uiTreeHelper.getNodeAttribute(scope,"selected"),scope.$watch(attrs.selected,function(val){"boolean"==typeof val&&(scope.selected=val)}),scope.$watch("selected",function(val){$uiTreeHelper.setNodeAttribute(scope,"selected",val),attrs.$set("selected",val)}),scope.$watch(attrs.expandOnHover,function(val){scope.expandOnHover=val});var firstMoving,pos,placeElm,hiddenPlaceElm,dragElm,treeScope,elements,dragTimer,documentHeight,documentWidth,hasTouch="ontouchstart"in window,dragDelaying=!0,dragStarted=!1,body=document.body,html=document.documentElement,toggleSelect=function(e){e.preventDefault(),e.stopPropagation(),removeChildSelect(scope),checkParentSelect(scope)||scope.$apply(scope.toggleSelected)},checkParentSelect=function(elementScope,count){elementScope=angular.isUndefined(elementScope)?scope:elementScope,count=angular.isUndefined(count)?0:count;var selected=!1;return null!==elementScope&&(selected=!1,!selected&&angular.isDefined(elementScope.$parent)&&(selected=checkParentSelect(elementScope.$parent,count+1)),!selected&&count>0&&(selected=angular.isDefined(elementScope.selected)?elementScope.selected:!1)),selected},removeChildSelect=function(elementScope){elementScope=angular.isUndefined(elementScope)?scope:elementScope,elementScope.hasChild()&&angular.forEach(elementScope.childNodes(),function(childNodeScope){childNodeScope.$apply(childNodeScope.unselect),removeChildSelect(childNodeScope)})},dragStart=function(e){if(scope.$treeScope.dragDistance>0){var eventObj=$uiTreeHelper.eventObj(e);pos=$uiTreeHelper.positionStarted(eventObj,scope.$element);var tempMoveFunction=function(tempEvent){tempEvent.preventDefault();var distance=Math.floor(Math.sqrt(Math.pow(tempEvent.pageX-pos.startX,2)+Math.pow(tempEvent.pageY-pos.startY,2)));distance>=scope.$treeScope.dragDistance&&(angular.element($document).unbind("touchmove",tempMoveFunction),angular.element($document).unbind("mousemove",tempMoveFunction),angular.element($document).unbind("touchend",tempEndFunction),angular.element($document).unbind("touchcancel",tempEndFunction),angular.element($document).unbind("mouseup",tempEndFunction),drag(e))};angular.element($document).bind("touchmove",tempMoveFunction),angular.element($document).bind("mousemove",tempMoveFunction);var tempEndFunction=function(tempEvent){tempEvent.preventDefault(),angular.element($document).unbind("touchmove",tempMoveFunction),angular.element($document).unbind("mousemove",tempMoveFunction),angular.element($document).unbind("touchend",tempEndFunction),angular.element($document).unbind("touchcancel",tempEndFunction),angular.element($document).unbind("mouseup",tempEndFunction),dragEndEvent(tempEvent)};angular.element($document).bind("touchend",tempEndFunction),angular.element($document).bind("touchcancel",tempEndFunction),angular.element($document).bind("mouseup",tempEndFunction)}else drag(e)},drag=function(e,restart){if(scope.$treeScope.dragEvent=angular.isDefined(e)&&!restart?e:scope.$treeScope.dragEvent,angular.isDefined(scope.$treeScope.dragEvent)){{$uiTreeHelper.offset(scope.$element)}if(!hasTouch&&(2==scope.$treeScope.dragEvent.button||3==scope.$treeScope.dragEvent.which))return;if((scope.$treeScope.dragEvent.uiTreeDragging||scope.$treeScope.dragEvent.originalEvent&&scope.$treeScope.dragEvent.originalEvent.uiTreeDragging)&&!restart)return;var eventElm=angular.element(scope.$treeScope.dragEvent.target),eventScope=eventElm.scope();if(!eventScope||!eventScope.$type)return;if("uiTreeNode"!=eventScope.$type&&"uiTreeHandle"!=eventScope.$type)return;if("uiTreeNode"==eventScope.$type&&eventScope.$handleScope)return;var eventElmTagName=eventElm.prop("tagName").toLowerCase();if("input"==eventElmTagName||"textarea"==eventElmTagName||"button"==eventElmTagName||"select"==eventElmTagName)return;for(;eventElm&&eventElm[0]&&eventElm[0]!=element;){if($uiTreeHelper.nodrag(eventElm))return;eventElm=eventElm.parent()}if(!scope.$parentNodesScope.beforeDrag(scope,scope.$treeScope.dragEvent)&&!restart)return;scope.$treeScope.dragEvent.uiTreeDragging=!0,scope.$treeScope.dragEvent.originalEvent&&(scope.$treeScope.dragEvent.originalEvent.uiTreeDragging=!0),scope.$treeScope.dragEvent.preventDefault(),$window.getSelection?$window.getSelection().removeAllRanges():$window.document.selection&&$window.document.selection.empty();var eventObj=$uiTreeHelper.eventObj(scope.$treeScope.dragEvent);if(restart)angular.forEach(scope.$treeScope.$selecteds,function(selectedElement){selectedElement=angular.element(selectedElement),scope.$treeScope.copy?selectedElement.removeClass(config.hiddenClass):selectedElement.addClass(config.hiddenClass)});else{if(firstMoving=!0,(angular.isUndefined(scope.$treeScope.$selecteds)||0===scope.$treeScope.$selecteds.length)&&(scope.$treeScope.$selecteds=[scope.$element]),scope.selected||(angular.forEach(scope.$treeScope.$selecteds,function(selectedElement){var selectedElementScope=angular.element(selectedElement).scope();selectedElementScope.$apply(function(){selectedElementScope.selected=!1})}),scope.$treeScope.$selecteds=[scope.$element]),scope.$treeScope.$selecteds.length>1&&(scope.$treeScope.$selecteds=$filter("orderBy")(scope.$treeScope.$selecteds,function(selectedElement){return $uiTreeHelper.offset(angular.element(selectedElement)).top},!1)),angular.isDefined(scope.$treeScope.$selecteds)&&scope.$treeScope.$selecteds.length>0){placeElm=angular.element($window.document.createElement("div")).addClass(config.placeHoldersWrapperClass),hiddenPlaceElm=angular.element($window.document.createElement("div")),dragElm=angular.element($window.document.createElement("div")).addClass(config.dragWrapperClass),pos=$uiTreeHelper.positionStarted(eventObj,angular.element(scope.$treeScope.$selecteds[0]));var firstElement=angular.element(scope.$treeScope.$selecteds[0]),firstElementOffset=angular.copy($uiTreeHelper.offset(firstElement));angular.forEach(scope.$treeScope.$selecteds,function(selected){var selectedElement=angular.element(selected),selectedElementScope=selectedElement.scope();selectedElementScope.$dragInfo=$uiTreeHelper.dragInfo(selectedElementScope);var selectedElementPlace,selectedElementHeight=$uiTreeHelper.height(selectedElement),selectedElementWidth=$uiTreeHelper.width(selectedElement),tagName=selectedElement.prop("tagName");if("tr"===tagName.toLowerCase()){selectedElementPlace=angular.element($window.document.createElement(tagName));var tdElm=angular.element($window.document.createElement("td")).addClass(config.placeHolderClass);selectedElementPlace.append(tdElm)}else selectedElementPlace=angular.element($window.document.createElement(tagName)).addClass(config.placeHolderClass);selectedElementPlace.css("height",selectedElementHeight+"px"),placeElm.append(selectedElementPlace);var selectedElementHiddenPlace=angular.element($window.document.createElement(tagName));config.hiddenClass&&selectedElementHiddenPlace.addClass(config.hiddenClass),hiddenPlaceElm.append(selectedElementHiddenPlace);var selectedElementDrag=angular.element($window.document.createElement(selectedElementScope.$parentNodesScope.$element.prop("tagName"))).addClass(selectedElementScope.$parentNodesScope.$element.attr("class"));selectedElementDrag.css("width",selectedElementWidth+"px");var clone=selectedElement.clone();selectedElementDrag.append(clone),scope.$treeScope.copy||selectedElement.addClass(config.hiddenClass),dragElm.append(selectedElementDrag);var hStyle=(scope.$element[0].querySelector(".angular-ui-tree-handle")||scope.$element[0]).currentStyle;hStyle&&(document.body.setAttribute("ui-tree-cursor",$document.find("body").css("cursor")||""),$document.find("body").css({cursor:hStyle.cursor+"!important"})),selectedElementScope.$apply(function(){selectedElementScope.selected=!1,selectedElementScope.original=!0})}),dragElm.css("z-index",9999).addClass(config.dragClass),firstElement.parent()[0].insertBefore(placeElm[0],firstElement[0]),firstElement.parent()[0].insertBefore(hiddenPlaceElm[0],firstElement[0]),$document.find("body").append(dragElm),dragElm.css({left:firstElementOffset.left+"px",top:firstElementOffset.top+"px"}),elements={placeholder:placeElm,dragging:dragElm},angular.element($document).bind("touchend",dragEndEvent),angular.element($document).bind("touchcancel",dragEndEvent),angular.element($document).bind("touchmove",dragMoveEvent),angular.element($document).bind("mouseup",dragEndEvent),angular.element($document).bind("mousemove",dragMoveEvent),angular.element($document).bind("mouseleave",dragCancelEvent)}documentHeight=Math.max(body.scrollHeight,body.offsetHeight,html.clientHeight,html.scrollHeight,html.offsetHeight),documentWidth=Math.max(body.scrollWidth,body.offsetWidth,html.clientWidth,html.scrollWidth,html.offsetWidth)}}},restartDrag=function(e){e.preventDefault(),scope.$treeScope.$selecteds.length>0&&drag(void 0,!0)},dragMove=function(e){if(!dragStarted)return void(dragDelaying||(dragStarted=!0,angular.forEach(scope.$treeScope.$selecteds,function(selectedElement){selectedElement=angular.element(selectedElement);var selectedElementScope=selectedElement.scope();selectedElementScope.$apply(function(){scope.$treeScope.$callbacks.dragStart(selectedElementScope.$dragInfo.eventArgs(elements,pos))})})));var hdlElm,eventObj=$uiTreeHelper.eventObj(e),elmPos={},elmOrigPos={},hdlPos={},boundToPos={};if(e.preventDefault(),$window.getSelection?$window.getSelection().removeAllRanges():$window.document.selection&&$window.document.selection.empty(),dragElm){elmOrigPos=$uiTreeHelper.offset(dragElm),elmPos.left=eventObj.pageX-pos.offsetX,elmPos.width=elmOrigPos.width,elmPos.right=elmPos.left+elmPos.width,elmPos.top=eventObj.pageY-pos.offsetY,elmPos.height=elmOrigPos.height,elmPos.bottom=elmPos.top+elmPos.height,hdlElm=scope.$element.find(config.handleClass);var hdlElmOffset;if(angular.isDefined(hdlElm)&&hdlElm.length>0?(hdlElmOffset=$uiTreeHelper.offset(hdlElm),hdlPos.left=hdlElmOffset.left,hdlPos.width=hdlElmOffset.width,hdlPos.top=hdlElmOffset.top,hdlPos.height=hdlElmOffset.height,hdlPos.offset=hdlElm.position().top):(hdlPos.left=elmPos.left,hdlPos.width=elmPos.width,hdlPos.top=elmPos.top),hdlPos.right=hdlPos.left+hdlPos.width,hdlPos.bottom=hdlPos.top+hdlPos.height,angular.isDefined(scope.$treeScope.boundTo)&&scope.$treeScope.boundTo.length>0){var boundToOffset=$uiTreeHelper.offset(scope.$treeScope.boundTo);boundToPos.left=boundToOffset.left,boundToPos.width=boundToOffset.width,boundToPos.top=boundToOffset.top,boundToPos.height=boundToOffset.height}else boundToPos.left=0,boundToPos.width=documentWidth,boundToPos.top=0,boundToPos.height=documentHeight;boundToPos.right=boundToPos.left+boundToPos.width,boundToPos.bottom=boundToPos.top+boundToPos.height,elmPos.left<boundToPos.left&&(elmPos.left=boundToPos.left),elmPos.top<boundToPos.top&&(elmPos.top=boundToPos.top),elmPos.left>boundToPos.right&&(elmPos.left=boundToPos.right),elmPos.top>boundToPos.bottom&&(elmPos.top=boundToPos.bottom),scope.$treeScope.lockY&&(elmPos.top=elmOrigPos.top),scope.$treeScope.lockX&&(elmPos.left=elmOrigPos.left),dragElm.css({left:elmPos.left+"px",top:elmPos.top+"px"});var topScroll=window.pageYOffset||$window.document.documentElement.scrollTop,bottomScroll=topScroll+(window.innerHeight||$window.document.clientHeight||$window.document.clientHeight);if(bottomScroll<eventObj.pageY&&documentHeight>=bottomScroll&&window.scrollBy(0,10),topScroll>eventObj.pageY&&window.scrollBy(0,-10),$uiTreeHelper.positionMoved(e,pos,firstMoving),firstMoving)return void(firstMoving=!1);var displayElm,targetX=elmPos.left+elmPos.width/2,targetY=elmPos.top+elmPos.height*scope.$treeScope.coverage;angular.isFunction(dragElm.hide)?dragElm.hide():(displayElm=dragElm[0].style.display,dragElm[0].style.display="none");var placeDisplayElm;angular.isFunction(placeElm.hide)?placeElm.hide():(placeDisplayElm=placeElm[0].style.display,placeElm[0].style.display="none"),$window.document.elementFromPoint(targetX,targetY);var closestElement=angular.element($window.document.elementFromPoint(targetX,targetY));angular.isFunction(placeElm.show)?placeElm.show():placeElm[0].style.display=placeDisplayElm,angular.isFunction(dragElm.show)?dragElm.show():dragElm[0].style.display=displayElm;
var targetNode,targetElm,isEmpty,isTree,targetElmOffset,selectedScope,closestScope=closestElement.scope();angular.isDefined(closestScope)&&angular.isDefined(closestScope.$nodeScope)?closestScope=closestScope.$nodeScope:angular.isDefined(closestScope)&&angular.isDefined(closestScope.$nodesScope)&&(closestScope=closestScope.$nodesScope),selectedScope=angular.isDefined(closestScope)&&angular.isDefined(closestScope.$treeScope)&&angular.isDefined(closestScope.$treeScope.$treeElement)&&angular.isDefined(closestScope.$treeScope.$treeElement.children())?closestScope:scope;var nodes=selectedScope.$treeScope.$treeElement.children(),treeChange=angular.isUndefined(scope.previousTreeId)||0===scope.previousTreeId.length||angular.isUndefined(selectedScope.$treeScope)||scope.previousTreeId!==selectedScope.$treeScope.$id;scope.previousTreeId=angular.isDefined(selectedScope.$treeScope)?selectedScope.$treeScope.$id:void 0;var direction=treeChange?1:pos.dirAx?pos.dirX:pos.dirY,intersectWith=$uiTreeHelper.findIntersect(elmPos,nodes,scope.$treeScope.collideWith,direction,scope.$parentNodesScope.horizontal);if(angular.isDefined(intersectWith)&&(targetElm=angular.element(intersectWith)),pos.moving||treeChange){var dragInfo=angular.element(scope.$treeScope.$selecteds[0]).scope().$dragInfo,previous=dragInfo.prev(),parent=dragInfo.parentNode();if(angular.isDefined(previous)&&!previous.collapsed&&angular.isDefined(previous.$childNodesScope)){var previousElmOffset=$uiTreeHelper.offset(previous.$element);elmPos.left>=previousElmOffset.left+scope.$treeScope.spacing-scope.$treeScope.spacingThreshold&&(previous.accept(scope,previous.childNodesCount())&&previous.$childNodesScope.$element.append(placeElm),angular.forEach(scope.$treeScope.$selecteds,function(selectedElement,index){var selectedElementScope=angular.element(selectedElement).scope();selectedElementScope.moved=selectedElementScope.$dragInfo.moveTo(previous.$childNodesScope,previous.childNodes(),previous.childNodesCount()+index)}),scope.asChild=!0)}if(parent=dragInfo.parentNode(),angular.isDefined(parent)){var parentElmOffset=$uiTreeHelper.offset(parent.$element);elmPos.left<=parentElmOffset.left+scope.$treeScope.spacingThreshold&&(dragInfo.next()||(parent.accept(scope,parent.index()+1)&&parent.$element.after(placeElm),angular.forEach(scope.$treeScope.$selecteds,function(selectedElement,index){var selectedElementScope=angular.element(selectedElement).scope();selectedElementScope.moved=selectedElementScope.$dragInfo.moveTo(parent.$parentNodesScope,parent.siblings(),parent.index()+1+index)}),scope.asChild=!1))}if(angular.isUndefined(targetElm))return;if(targetNode=targetElm.scope(),!targetNode)return;if(isEmpty=!1,isTree=!1,"uiTree"==targetNode.$type&&targetNode.dragEnabled&&(isEmpty=targetNode.isEmpty()),"uiTreeHandle"==targetNode.$type&&(targetNode=targetNode.$nodeScope),"uiTreeNode"!=targetNode.$type&&!isEmpty){if("uiTree"!=targetNode.$type)return;isTree=!0}if(targetElm=targetNode.$element,targetElmOffset=$uiTreeHelper.offset(targetElm),treeScope&&placeElm.parent()[0]!=treeScope.$element[0]&&(treeScope.resetEmptyElement(),treeScope=void 0),isEmpty)treeScope=targetNode,targetNode.accept(scope,0)&&targetNode.place(placeElm),angular.forEach(scope.$treeScope.$selecteds,function(selectedElement,index){var selectedElementScope=angular.element(selectedElement).scope();selectedElementScope.moved=selectedElementScope.$dragInfo.moveTo(targetNode.$parentNodesScope,targetNode.$parentNodesScope.childNodes(),index)});else if(isTree)targetNode.accept(scope,targetNode.$parentNodesScope.childNodes().length+1)&&targetNode.place(placeElm),angular.forEach(scope.$treeScope.$selecteds,function(selectedElement,index){var selectedElementScope=angular.element(selectedElement).scope();selectedElementScope.moved=selectedElementScope.$dragInfo.moveTo(targetNode.$parentNodesScope,targetNode.$parentNodesScope.childNodes(),targetNode.$parentNodesScope.childNodes().length+1+index)});else if(targetNode.dragEnabled()){if(angular.forEach(scope.$treeScope.$selecteds,function(selectedElement){var selectedElementScope=angular.element(selectedElement).scope();angular.isDefined(selectedElementScope.expandTimeoutOn)&&selectedElementScope.expandTimeoutOn!==targetNode.id&&($timeout.cancel(selectedElementScope.expandTimeout),delete selectedElementScope.expandTimeout,delete selectedElementScope.expandTimeoutOn,targetNode.$apply(function(){scope.$treeScope.$callbacks.expandTimeoutCancel()}))}),targetNode.collapsed){var expandOnHover=targetNode.expandOnHover||targetNode.$parentNodesScope.expandOnHover||targetNode.$treeScope.expandOnHover;expandOnHover===!0||angular.isNumber(expandOnHover)&&0===expandOnHover?targetNode.collapsed=!1:expandOnHover!==!1&&angular.isNumber(expandOnHover)&&expandOnHover>0&&angular.forEach(scope.$treeScope.$selecteds,function(selectedElement){var selectedElementScope=angular.element(selectedElement).scope();angular.isUndefined(selectedElementScope.expandTimeoutOn)&&(selectedElementScope.expandTimeoutOn=targetNode.$id,targetNode.$apply(function(){targetNode.$treeScope.$callbacks.expandTimeoutStart()}),selectedElementScope.expandTimeout=$timeout(function(){targetNode.$apply(function(){targetNode.collapsed=!targetNode.$treeScope.$callbacks.expandTimeoutEnd()})},expandOnHover))})}var childsHeight=targetNode.hasChild()?$uiTreeHelper.offset(targetNode.$childNodesScope.$element).height:0;if(!scope.$parentNodesScope.horizontal&&pos.dirY>0||scope.$parentNodesScope.horizontal&&pos.dirX>0||treeChange){var elmVertDown="top"===scope.$treeScope.collideWith?scope.$parentNodesScope.horizontal?elmPos.right:elmPos.top:scope.$parentNodesScope.horizontal?elmPos.left:elmPos.bottom,downLimit=scope.$parentNodesScope.horizontal?targetElmOffset.left-elmPos.left+targetElmOffset.width*scope.$treeScope.coverage:targetElmOffset.top+(targetElmOffset.height-childsHeight)*scope.$treeScope.coverage;if(elmVertDown>=downLimit)if(!targetNode.collapsed&&targetNode.hasChild()||scope.asChild){var firstChild=targetNode.childNodes().length>0?targetNode.childNodes()[0]:void 0,firstChildOffset=angular.isDefined(firstChild)?$uiTreeHelper.offset(firstChild.$element):void 0,firstChildChildsHeight=angular.isDefined(firstChild)&&firstChild.hasChild()?$uiTreeHelper.offset(firstChild.$childNodesScope.$element).height:0;(angular.isUndefined(firstChild)||angular.isDefined(firstChild)&&elmVertDown<firstChildOffset.top+(firstChildOffset.height-firstChildChildsHeight)*scope.$treeScope.coverage)&&(targetNode.accept(scope,0)&&targetNode.$childNodesScope.$element.prepend(placeElm),angular.forEach(scope.$treeScope.$selecteds,function(selectedElement,index){var selectedElementScope=angular.element(selectedElement).scope();selectedElementScope.moved=selectedElementScope.$dragInfo.moveTo(targetNode.$childNodesScope,targetNode.childNodes(),index)}))}else targetNode.accept(scope,targetNode.index()+1)&&targetElm.after(placeElm),angular.forEach(scope.$treeScope.$selecteds,function(selectedElement,index){var selectedElementScope=angular.element(selectedElement).scope();selectedElementScope.moved=selectedElementScope.$dragInfo.moveTo(targetNode.$parentNodesScope,targetNode.siblings(),targetNode.index()+1+index)})}if((!scope.$parentNodesScope.horizontal&&pos.dirY<0||scope.$parentNodesScope.horizontal&&pos.dirX<0)&&(!scope.$parentNodesScope.horizontal&&pos.distAxY>config.dragUpThreshold||!scope.$parentNodesScope.horizontal&&pos.distAxX>8)||treeChange){var elmVertUp="top"===scope.$treeScope.collideWith?scope.$parentNodesScope.horizontal?elmPos.left:elmPos.bottom:scope.$parentNodesScope.horizontal?elmPos.right:elmPos.top,upLimit=scope.$parentNodesScope.horizontal?targetElmOffset.left-elmPos.left+targetElmOffset.width-targetElmOffset.width*scope.$treeScope.coverage:targetElmOffset.top+targetElmOffset.height-childsHeight-(targetElmOffset.height-childsHeight)*scope.$treeScope.coverage;upLimit>=elmVertUp&&(targetNode.accept(scope,targetNode.index())&&targetElm[0].parentNode.insertBefore(placeElm[0],targetElm[0]),angular.forEach(scope.$treeScope.$selecteds,function(selectedElement,index){var selectedElementScope=angular.element(selectedElement).scope();selectedElementScope.moved=selectedElementScope.$dragInfo.moveTo(targetNode.$parentNodesScope,targetNode.siblings(),targetNode.index()+index)}))}angular.forEach(scope.$treeScope.$selecteds,function(selectedElement){var selectedElementScope=angular.element(selectedElement).scope();if(selectedElementScope.moved){var dragInfoEventsArgs=selectedElementScope.$dragInfo.eventArgs(elements,pos);angular.isDefined(dragInfoEventsArgs)&&angular.isDefined(dragInfoEventsArgs.dest)&&(angular.isUndefined(selectedElementScope.dragInfoEventsArgs)||angular.isUndefined(selectedElementScope.dragInfoEventsArgs.dest)||!angular.equals(selectedElementScope.dragInfoEventsArgs.dest,dragInfoEventsArgs.dest))&&(selectedElementScope.$apply(function(){scope.$treeScope.$callbacks.placeholderMove(dragInfoEventsArgs)}),selectedElementScope.dragInfoEventsArgs=dragInfoEventsArgs)}})}}}angular.forEach(scope.$treeScope.$selecteds,function(selectedElement){var selectedElementScope=angular.element(selectedElement).scope();selectedElementScope.$apply(function(){scope.$treeScope.$callbacks.dragMove(selectedElementScope.$dragInfo.eventArgs(elements,pos))})})},dragEnd=function(e,cancel){if(angular.isDefined(e)&&e.preventDefault(),$timeout.cancel(scope.expandTimeout),angular.isDefined(dragElm)&&angular.isDefined(e)){{angular.copy(scope.$treeScope.$selecteds.length)}angular.forEach(scope.$treeScope.$selecteds,function(selectedElement){var selectedElementScope=angular.element(selectedElement).scope();if(angular.isDefined(selectedElementScope)){var dragInfoEventArgs=selectedElementScope.$dragInfo.eventArgs(elements,pos);selectedElementScope.$apply(function(){selectedElementScope.$$apply=scope.$treeScope.$callbacks.beforeDrop(dragInfoEventArgs)}),selectedElementScope.$$apply&&!cancel?(selectedElementScope.$dragInfo.apply(scope.$treeScope.copy),selectedElementScope.$apply(function(){scope.$treeScope.$callbacks.dropped(dragInfoEventArgs)}),dragInfoEventArgs.dest.nodesScope.$apply(function(){scope.$treeScope.$callbacks.droppedInto(dragInfoEventArgs)})):(selectedElementScope.$element.removeClass(config.hiddenClass),selectedElementScope.$apply(function(){scope.$treeScope.$callbacks.dragCancel(dragInfoEventArgs)})),selectedElementScope.$apply(function(){scope.$treeScope.$callbacks.dragStop(dragInfoEventArgs)}),selectedElementScope.$dragInfo=void 0,selectedElementScope.$apply(function(){delete selectedElementScope.original})}}),angular.isDefined(placeElm)&&(placeElm.remove(),placeElm=void 0),angular.isDefined(hiddenPlaceElm)&&(hiddenPlaceElm.remove(),hiddenPlaceElm=void 0),angular.isDefined(dragElm)&&(dragElm.remove(),dragElm=void 0),scope.$treeScope.$selecteds=[]}var oldCur=document.body.getAttribute("ui-tree-cursor");null!==oldCur&&($document.find("body").css({cursor:oldCur}),document.body.removeAttribute("ui-tree-cursor")),angular.element($document).unbind("touchend",dragEndEvent),angular.element($document).unbind("touchcancel",dragEndEvent),angular.element($document).unbind("touchmove",dragMoveEvent),angular.element($document).unbind("mouseup",dragEndEvent),angular.element($document).unbind("mousemove",dragMoveEvent),angular.element($window.document.body).unbind("mouseleave",dragCancelEvent)},dragStartEvent=function(e){scope.dragEnabled()&&dragStart(e)},dragMoveEvent=function(e){dragMove(e)},dragEndEvent=function(e){angular.forEach(scope.$treeScope.$selecteds,function(selected){var selectedElement=angular.element(selected);if(angular.isDefined(selectedElement)){var selectedElementScope=selectedElement.scope();angular.isDefined(selectedElementScope)&&(selectedElementScope.$$apply=!0)}}),dragEnd(e)},dragCancelEvent=function(e){angular.forEach(scope.$treeScope.$selecteds,function(selected){var selectedElement=angular.element(selected);if(angular.isDefined(selectedElement)){var selectedElementScope=selectedElement.scope();angular.isDefined(selectedElementScope)&&(selectedElementScope.$$apply=!1)}}),dragEnd(e,!0)},bindDrag=function(){element.bind("touchstart mousedown",function(e){scope.$treeScope.multiSelect?toggleSelect(e):(dragDelaying=!0,dragStarted=!1,dragTimer=$timeout(function(){dragStartEvent(e),dragDelaying=!1},scope.$treeScope.dragDelay))}),element.bind("touchend touchcancel mouseup",function(){$timeout.cancel(dragTimer)})},unbind=function(){dragEnd(),angular.element($window.document.body).unbind("keydown").unbind("keyup")};bindDrag(),angular.element($window.document.body).bind("keydown",function(e){e.keyCode===scope.$treeScope.cancelKey&&dragCancelEvent(e),angular.isDefined(scope.$treeScope.lockXKey)&&e.keyCode===scope.$treeScope.lockXKey&&scope.$treeScope.$apply(function(){scope.$treeScope.lockX=scope.$treeScope.$callbacks.lock("X")}),angular.isDefined(scope.$treeScope.lockYKey)&&e.keyCode===scope.$treeScope.lockYKey&&scope.$treeScope.$apply(function(){scope.$treeScope.lockY=scope.$treeScope.$callbacks.lock("Y")}),e.keyCode===scope.$treeScope.copyKey?scope.$treeScope.copy||(scope.$treeScope.$apply(function(){scope.$treeScope.copy=scope.$treeScope.$callbacks.startCopy()}),restartDrag(e)):e.keyCode===scope.$treeScope.multiSelectKey&&(scope.$treeScope.multiSelect||scope.$treeScope.$apply(function(){scope.$treeScope.multiSelect=scope.$treeScope.$callbacks.startSelect()}))}),angular.element($window.document.body).bind("keyup",function(e){angular.isDefined(scope.$treeScope.lockXKey)&&e.keyCode===scope.$treeScope.lockXKey&&scope.$treeScope.$apply(function(){scope.$treeScope.lockX=!scope.$treeScope.$callbacks.unlock("X")}),angular.isDefined(scope.$treeScope.lockYKey)&&e.keyCode===scope.$treeScope.lockYKey&&scope.$treeScope.$apply(function(){scope.$treeScope.lockY=!scope.$treeScope.$callbacks.unlock("Y")}),e.keyCode===scope.$treeScope.copyKey?scope.$treeScope.copy&&(scope.$treeScope.$apply(function(){scope.$treeScope.copy=!scope.$treeScope.$callbacks.endCopy()}),restartDrag(e)):e.keyCode===scope.$treeScope.multiSelectKey&&scope.$treeScope.multiSelect&&scope.$treeScope.$apply(function(){scope.$treeScope.multiSelect=!scope.$treeScope.$callbacks.endSelect()})}),scope.$on("$destroy",unbind)}}}])}(),function(){"use strict";angular.module("ui.tree").directive("uiTreeHandle",["treeConfig",function(treeConfig){return{require:"^uiTreeNode",restrict:"A",scope:!0,controller:"TreeHandleController",link:function(scope,element,attrs,treeNodeCtrl){var config={};angular.extend(config,treeConfig),config.handleClass&&element.addClass(config.handleClass),scope!=treeNodeCtrl.scope&&(scope.$nodeScope=treeNodeCtrl.scope,treeNodeCtrl.scope.$handleScope=scope)}}}])}();